'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cloudevents = require('cloudevents');
var url = require('url');
var logger$1 = require('@azure/logger');

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 *
 * @internal
 */
const logger = logger$1.createClientLogger("web-pubsub-express");

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
function isJsonObject(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
}
function toBase64JsonString(obj) {
    return Buffer.from(JSON.stringify(obj)).toString("base64");
}
function fromBase64JsonString(base64String) {
    if (base64String === undefined) {
        return {};
    }
    try {
        const buf = Buffer.from(base64String, "base64").toString();
        const parsed = JSON.parse(buf);
        return isJsonObject(parsed) ? parsed : {};
    }
    catch (e) {
        console.warn("Unexpected state format:" + e);
        return {};
    }
}
function getHttpHeader(req, key) {
    const value = req.headers[key];
    if (value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    return value[0];
}
async function convertHttpToEvent(request) {
    const normalized = {
        headers: {},
        body: ""
    };
    if (request.headers) {
        for (const key in request.headers) {
            if (Object.prototype.hasOwnProperty.call(request.headers, key)) {
                const element = request.headers[key];
                if (element !== undefined) {
                    normalized.headers[key.toLowerCase()] = element;
                }
            }
        }
    }
    normalized.body = await readRequestBody(request);
    return normalized;
}
function readRequestBody(req) {
    return new Promise(function (resolve, reject) {
        const chunks = [];
        req.on("data", function (chunk) {
            chunks.push(chunk);
        });
        req.on("end", function () {
            const buffer = Buffer.concat(chunks);
            resolve(buffer.toString());
        });
        // reject on request error
        req.on("error", function (err) {
            // This is not a "Second reject", just a different sort of failure
            reject(err);
        });
    });
}

// Copyright (c) Microsoft Corporation.
var EventType;
(function (EventType) {
    EventType[EventType["Connect"] = 0] = "Connect";
    EventType[EventType["Connected"] = 1] = "Connected";
    EventType[EventType["Disconnected"] = 2] = "Disconnected";
    EventType[EventType["UserEvent"] = 3] = "UserEvent";
})(EventType || (EventType = {}));
function getConnectResponseHandler(connectRequest, response) {
    const states = connectRequest.context.states;
    let modified = false;
    const handler = {
        setState(name, value) {
            states[name] = value;
            modified = true;
        },
        success(res) {
            response.statusCode = 200;
            if (modified) {
                response.setHeader("ce-connectionState", toBase64JsonString(states));
            }
            if (res === undefined) {
                response.end();
            }
            else {
                response.setHeader("Content-Type", "application/json; charset=utf-8");
                response.end(JSON.stringify(res));
            }
        },
        fail(code, detail) {
            response.statusCode = code;
            response.end(detail !== null && detail !== void 0 ? detail : "");
        }
    };
    return handler;
}
function getUserEventResponseHandler(userRequest, response) {
    const states = userRequest.context.states;
    let modified = false;
    const handler = {
        setState(name, value) {
            modified = true;
            states[name] = value;
        },
        success(data, dataType) {
            response.statusCode = 200;
            if (modified) {
                response.setHeader("ce-connectionState", toBase64JsonString(states));
            }
            switch (dataType) {
                case "json":
                    response.setHeader("Content-Type", "application/json; charset=utf-8");
                    break;
                case "text":
                    response.setHeader("Content-Type", "text/plain; charset=utf-8");
                    break;
                default:
                    response.setHeader("Content-Type", "application/octet-stream");
                    break;
            }
            response.end(data !== null && data !== void 0 ? data : "");
        },
        fail(code, detail) {
            response.statusCode = code;
            response.end(detail !== null && detail !== void 0 ? detail : "");
        }
    };
    return handler;
}
function getContext(ce, origin) {
    const context = {
        signature: ce["signature"],
        userId: ce["userid"],
        hub: ce["hub"],
        connectionId: ce["connectionid"],
        eventName: ce["eventname"],
        origin: origin,
        states: fromBase64JsonString(ce["connectionstate"])
    };
    // TODO: validation
    return context;
}
function tryGetWebPubSubEvent(req) {
    // check ce-type to see if it is a valid WebPubSub CloudEvent request
    const prefix = "azure.webpubsub.";
    const connect = "azure.webpubsub.sys.connect";
    const connected = "azure.webpubsub.sys.connected";
    const disconnectd = "azure.webpubsub.sys.disconnected";
    const userPrefix = "azure.webpubsub.user.";
    const type = getHttpHeader(req, "ce-type");
    if (!(type === null || type === void 0 ? void 0 : type.startsWith(prefix))) {
        return undefined;
    }
    if (type.startsWith(userPrefix)) {
        return EventType.UserEvent;
    }
    switch (type) {
        case connect:
            return EventType.Connect;
        case connected:
            return EventType.Connected;
        case disconnectd:
            return EventType.Disconnected;
        default:
            return undefined;
    }
}
function isWebPubSubRequest(req) {
    return getHttpHeader(req, "ce-awpsversion") !== undefined;
}
/**
 * @internal
 */
class CloudEventsDispatcher {
    constructor(hub, eventHandler) {
        this.hub = hub;
        this.eventHandler = eventHandler;
        this._allowAll = true;
        this._allowedOrigins = [];
        if (Array.isArray(eventHandler)) {
            throw new Error("Unexpected WebPubSubEventHandlerOptions");
        }
        if ((eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.allowedEndpoints) !== undefined) {
            this._allowedOrigins = eventHandler.allowedEndpoints.map((endpoint) => new url.URL(endpoint).host.toLowerCase());
            this._allowAll = false;
        }
    }
    handlePreflight(req, res) {
        var _a;
        if (!isWebPubSubRequest(req)) {
            return false;
        }
        const origin = (_a = getHttpHeader(req, "webhook-request-origin")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (origin === undefined) {
            logger.warning("Expecting webhook-request-origin header.");
            res.statusCode = 400;
        }
        else if (this._allowAll || this._allowedOrigins.indexOf(origin) > -1) {
            res.setHeader("WebHook-Allowed-Origin", origin);
        }
        else {
            logger.warning("Origin does not match the allowed origins: " + this._allowedOrigins);
            res.statusCode = 400;
        }
        res.end();
        return true;
    }
    async handleRequest(request, response) {
        var _a, _b, _c, _d, _e;
        if (!isWebPubSubRequest(request)) {
            return false;
        }
        // check if it is a valid WebPubSub cloud events
        const origin = getHttpHeader(request, "webhook-request-origin");
        if (origin === undefined) {
            return false;
        }
        const eventType = tryGetWebPubSubEvent(request);
        if (eventType === undefined) {
            return false;
        }
        // check if hub matches
        const hub = getHttpHeader(request, "ce-hub");
        if (hub !== this.hub) {
            return false;
        }
        // No need to read body if handler is not specified
        switch (eventType) {
            case EventType.Connect:
                if (!((_a = this.eventHandler) === null || _a === void 0 ? void 0 : _a.handleConnect)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.Connected:
                if (!((_b = this.eventHandler) === null || _b === void 0 ? void 0 : _b.onConnected)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.Disconnected:
                if (!((_c = this.eventHandler) === null || _c === void 0 ? void 0 : _c.onDisconnected)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.UserEvent:
                if (!((_d = this.eventHandler) === null || _d === void 0 ? void 0 : _d.handleUserEvent)) {
                    response.end();
                    return true;
                }
                break;
            default:
                logger.warning(`Unknown EventType ${eventType}`);
                return false;
        }
        const eventRequest = await convertHttpToEvent(request);
        const receivedEvent = cloudevents.HTTP.toEvent(eventRequest);
        logger.verbose(receivedEvent);
        switch (eventType) {
            case EventType.Connect: {
                const connectRequest = receivedEvent.data;
                connectRequest.context = getContext(receivedEvent, origin);
                this.eventHandler.handleConnect(connectRequest, getConnectResponseHandler(connectRequest, response));
                return true;
            }
            case EventType.Connected: {
                // for unblocking events, we responds to the service as early as possible
                response.end();
                const connectedRequest = receivedEvent.data;
                connectedRequest.context = getContext(receivedEvent, origin);
                this.eventHandler.onConnected(connectedRequest);
                return true;
            }
            case EventType.Disconnected: {
                // for unblocking events, we responds to the service as early as possible
                response.end();
                const disconnectedRequest = receivedEvent.data;
                disconnectedRequest.context = getContext(receivedEvent, origin);
                this.eventHandler.onDisconnected(disconnectedRequest);
                return true;
            }
            case EventType.UserEvent: {
                let userRequest;
                if (receivedEvent.data_base64 !== undefined) {
                    userRequest = {
                        context: getContext(receivedEvent, origin),
                        data: Buffer.from(receivedEvent.data_base64, "base64"),
                        dataType: "binary"
                    };
                }
                else if (receivedEvent.data !== undefined) {
                    userRequest = {
                        context: getContext(receivedEvent, origin),
                        data: receivedEvent.data,
                        dataType: ((_e = receivedEvent.datacontenttype) === null || _e === void 0 ? void 0 : _e.startsWith("application/json;"))
                            ? "json"
                            : "text"
                    };
                }
                else {
                    throw new Error("Unexpected data.");
                }
                this.eventHandler.handleUserEvent(userRequest, getUserEventResponseHandler(userRequest, response));
                return true;
            }
            default:
                logger.warning(`Unknown EventType ${eventType}`);
                return false;
        }
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The handler to handle incoming CloudEvents messages
 */
class WebPubSubEventHandler {
    /**
     * Creates an instance of a WebPubSubEventHandler for handling incoming CloudEvents messages.
     *
     * Example usage:
     * ```ts
     * import express from "express";
     * import { WebPubSubEventHandler } from "@azure/web-pubsub-express";
     * const endpoint = "https://xxxx.webpubsubdev.azure.com"
     * const handler = new WebPubSubEventHandler('chat', {
     *   handleConnect: (req, res) => {
     *     console.log(JSON.stringify(req));
     *     return {};
     *   },
     *   onConnected: req => {
     *     console.log(JSON.stringify(req));
     *   },
     *   handleUserEvent: (req, res) => {
     *     console.log(JSON.stringify(req));
     *     res.success("Hey " + req.data, req.dataType);
     *    };
     *   allowedEndpoints: [ endpoint ]
     *  },
     * });
     * ```
     *
     * @param hub - The name of the hub to listen to
     * @param options - Options to configure the event handler
     */
    constructor(hub, options) {
        var _a;
        this.hub = hub;
        const path = ((_a = options === null || options === void 0 ? void 0 : options.path) !== null && _a !== void 0 ? _a : `/api/webpubsub/hubs/${hub}/`).toLowerCase();
        this.path = path.endsWith("/") ? path : path + "/";
        this._cloudEventsHandler = new CloudEventsDispatcher(this.hub, options);
    }
    /**
     * Get the middleware to process the CloudEvents requests
     */
    getMiddleware() {
        return async (req, res, next) => {
            // Request originalUrl can contain query while baseUrl + path not
            let requestUrl = (req.baseUrl + req.path).toLowerCase();
            // normalize the Url
            requestUrl = requestUrl.endsWith("/") ? requestUrl : requestUrl + "/";
            if (requestUrl.startsWith(this.path)) {
                if (req.method === "OPTIONS") {
                    if (this._cloudEventsHandler.handlePreflight(req, res)) {
                        return;
                    }
                }
                else if (req.method === "POST") {
                    try {
                        if (await this._cloudEventsHandler.handleRequest(req, res)) {
                            return;
                        }
                    }
                    catch (err) {
                        next(err);
                        return;
                    }
                }
            }
            next();
        };
    }
}

exports.WebPubSubEventHandler = WebPubSubEventHandler;
//# sourceMappingURL=index.js.map
