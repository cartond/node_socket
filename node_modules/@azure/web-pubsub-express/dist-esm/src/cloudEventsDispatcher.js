// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { HTTP } from "cloudevents";
import { URL } from "url";
import { logger } from "./logger";
import * as utils from "./utils";
var EventType;
(function (EventType) {
    EventType[EventType["Connect"] = 0] = "Connect";
    EventType[EventType["Connected"] = 1] = "Connected";
    EventType[EventType["Disconnected"] = 2] = "Disconnected";
    EventType[EventType["UserEvent"] = 3] = "UserEvent";
})(EventType || (EventType = {}));
function getConnectResponseHandler(connectRequest, response) {
    const states = connectRequest.context.states;
    let modified = false;
    const handler = {
        setState(name, value) {
            states[name] = value;
            modified = true;
        },
        success(res) {
            response.statusCode = 200;
            if (modified) {
                response.setHeader("ce-connectionState", utils.toBase64JsonString(states));
            }
            if (res === undefined) {
                response.end();
            }
            else {
                response.setHeader("Content-Type", "application/json; charset=utf-8");
                response.end(JSON.stringify(res));
            }
        },
        fail(code, detail) {
            response.statusCode = code;
            response.end(detail !== null && detail !== void 0 ? detail : "");
        }
    };
    return handler;
}
function getUserEventResponseHandler(userRequest, response) {
    const states = userRequest.context.states;
    let modified = false;
    const handler = {
        setState(name, value) {
            modified = true;
            states[name] = value;
        },
        success(data, dataType) {
            response.statusCode = 200;
            if (modified) {
                response.setHeader("ce-connectionState", utils.toBase64JsonString(states));
            }
            switch (dataType) {
                case "json":
                    response.setHeader("Content-Type", "application/json; charset=utf-8");
                    break;
                case "text":
                    response.setHeader("Content-Type", "text/plain; charset=utf-8");
                    break;
                default:
                    response.setHeader("Content-Type", "application/octet-stream");
                    break;
            }
            response.end(data !== null && data !== void 0 ? data : "");
        },
        fail(code, detail) {
            response.statusCode = code;
            response.end(detail !== null && detail !== void 0 ? detail : "");
        }
    };
    return handler;
}
function getContext(ce, origin) {
    const context = {
        signature: ce["signature"],
        userId: ce["userid"],
        hub: ce["hub"],
        connectionId: ce["connectionid"],
        eventName: ce["eventname"],
        origin: origin,
        states: utils.fromBase64JsonString(ce["connectionstate"])
    };
    // TODO: validation
    return context;
}
function tryGetWebPubSubEvent(req) {
    // check ce-type to see if it is a valid WebPubSub CloudEvent request
    const prefix = "azure.webpubsub.";
    const connect = "azure.webpubsub.sys.connect";
    const connected = "azure.webpubsub.sys.connected";
    const disconnectd = "azure.webpubsub.sys.disconnected";
    const userPrefix = "azure.webpubsub.user.";
    const type = utils.getHttpHeader(req, "ce-type");
    if (!(type === null || type === void 0 ? void 0 : type.startsWith(prefix))) {
        return undefined;
    }
    if (type.startsWith(userPrefix)) {
        return EventType.UserEvent;
    }
    switch (type) {
        case connect:
            return EventType.Connect;
        case connected:
            return EventType.Connected;
        case disconnectd:
            return EventType.Disconnected;
        default:
            return undefined;
    }
}
function isWebPubSubRequest(req) {
    return utils.getHttpHeader(req, "ce-awpsversion") !== undefined;
}
/**
 * @internal
 */
export class CloudEventsDispatcher {
    constructor(hub, eventHandler) {
        this.hub = hub;
        this.eventHandler = eventHandler;
        this._allowAll = true;
        this._allowedOrigins = [];
        if (Array.isArray(eventHandler)) {
            throw new Error("Unexpected WebPubSubEventHandlerOptions");
        }
        if ((eventHandler === null || eventHandler === void 0 ? void 0 : eventHandler.allowedEndpoints) !== undefined) {
            this._allowedOrigins = eventHandler.allowedEndpoints.map((endpoint) => new URL(endpoint).host.toLowerCase());
            this._allowAll = false;
        }
    }
    handlePreflight(req, res) {
        var _a;
        if (!isWebPubSubRequest(req)) {
            return false;
        }
        const origin = (_a = utils.getHttpHeader(req, "webhook-request-origin")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (origin === undefined) {
            logger.warning("Expecting webhook-request-origin header.");
            res.statusCode = 400;
        }
        else if (this._allowAll || this._allowedOrigins.indexOf(origin) > -1) {
            res.setHeader("WebHook-Allowed-Origin", origin);
        }
        else {
            logger.warning("Origin does not match the allowed origins: " + this._allowedOrigins);
            res.statusCode = 400;
        }
        res.end();
        return true;
    }
    async handleRequest(request, response) {
        var _a, _b, _c, _d, _e;
        if (!isWebPubSubRequest(request)) {
            return false;
        }
        // check if it is a valid WebPubSub cloud events
        const origin = utils.getHttpHeader(request, "webhook-request-origin");
        if (origin === undefined) {
            return false;
        }
        const eventType = tryGetWebPubSubEvent(request);
        if (eventType === undefined) {
            return false;
        }
        // check if hub matches
        const hub = utils.getHttpHeader(request, "ce-hub");
        if (hub !== this.hub) {
            return false;
        }
        // No need to read body if handler is not specified
        switch (eventType) {
            case EventType.Connect:
                if (!((_a = this.eventHandler) === null || _a === void 0 ? void 0 : _a.handleConnect)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.Connected:
                if (!((_b = this.eventHandler) === null || _b === void 0 ? void 0 : _b.onConnected)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.Disconnected:
                if (!((_c = this.eventHandler) === null || _c === void 0 ? void 0 : _c.onDisconnected)) {
                    response.end();
                    return true;
                }
                break;
            case EventType.UserEvent:
                if (!((_d = this.eventHandler) === null || _d === void 0 ? void 0 : _d.handleUserEvent)) {
                    response.end();
                    return true;
                }
                break;
            default:
                logger.warning(`Unknown EventType ${eventType}`);
                return false;
        }
        const eventRequest = await utils.convertHttpToEvent(request);
        const receivedEvent = HTTP.toEvent(eventRequest);
        logger.verbose(receivedEvent);
        switch (eventType) {
            case EventType.Connect: {
                const connectRequest = receivedEvent.data;
                connectRequest.context = getContext(receivedEvent, origin);
                this.eventHandler.handleConnect(connectRequest, getConnectResponseHandler(connectRequest, response));
                return true;
            }
            case EventType.Connected: {
                // for unblocking events, we responds to the service as early as possible
                response.end();
                const connectedRequest = receivedEvent.data;
                connectedRequest.context = getContext(receivedEvent, origin);
                this.eventHandler.onConnected(connectedRequest);
                return true;
            }
            case EventType.Disconnected: {
                // for unblocking events, we responds to the service as early as possible
                response.end();
                const disconnectedRequest = receivedEvent.data;
                disconnectedRequest.context = getContext(receivedEvent, origin);
                this.eventHandler.onDisconnected(disconnectedRequest);
                return true;
            }
            case EventType.UserEvent: {
                let userRequest;
                if (receivedEvent.data_base64 !== undefined) {
                    userRequest = {
                        context: getContext(receivedEvent, origin),
                        data: Buffer.from(receivedEvent.data_base64, "base64"),
                        dataType: "binary"
                    };
                }
                else if (receivedEvent.data !== undefined) {
                    userRequest = {
                        context: getContext(receivedEvent, origin),
                        data: receivedEvent.data,
                        dataType: ((_e = receivedEvent.datacontenttype) === null || _e === void 0 ? void 0 : _e.startsWith("application/json;"))
                            ? "json"
                            : "text"
                    };
                }
                else {
                    throw new Error("Unexpected data.");
                }
                this.eventHandler.handleUserEvent(userRequest, getUserEventResponseHandler(userRequest, response));
                return true;
            }
            default:
                logger.warning(`Unknown EventType ${eventType}`);
                return false;
        }
    }
}
//# sourceMappingURL=cloudEventsDispatcher.js.map